<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>























  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"/>
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=6.7.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="驰哥哥教你学Java">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="驰哥哥教你学Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="驰哥哥教你学Java">






  <link rel="canonical" href="http://yoursite.com/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>驰哥哥教你学Java</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">驰哥哥教你学Java</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/8. 高频面试题-SpringBoot&SpringCloud/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/8. 高频面试题-SpringBoot&SpringCloud/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 08:58:06" itemprop="dateModified" datetime="2018-12-12T08:58:06+08:00">2018-12-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##高频面试题-SpringBoot&amp;SpringCloud<br>(1) 什么是springboot  </p>
<ul>
<li>用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件） </li>
<li>创建独立的spring引用程序 main方法运行</li>
<li>嵌入的Tomcat 无需部署war文件</li>
<li>简化maven配置</li>
<li>自动配置spring添加对应功能starter自动化配置</li>
</ul>
<p>(2) springboot常用的starter有哪些 </p>
<ul>
<li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li>
<li>spring-boot-starter-data-jpa 数据库支持</li>
<li>spring-boot-starter-data-redis redis数据库支持</li>
<li>spring-boot-starter-data-solr solr支持</li>
<li>mybatis-spring-boot-starter 第三方的mybatis集成starter</li>
</ul>
<p>(3) 你如何理解 Spring Boot 中的 Starters？</p>
<p>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。</p>
<p>(4) springboot自动配置的原理  </p>
<ul>
<li>在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration会自动去maven中读取每个starter中的spring.factories文件  该文件里配置了所有需要被创建spring容器中的bean</li>
</ul>
<p>(5) springboot读取配置文件的方式</p>
<ul>
<li>springboot默认读取配置文件为application.properties或者是application.yml. 最先会读取一个bootstrap.yml的文件</li>
</ul>
<p>(6) springboot集成mybatis的过程</p>
<ul>
<li>添加mybatis的starter maven依赖</li>
<li>在mybatis的接口中 添加@Mapper注解</li>
<li>在application.yml或者application.properties配置数据源信息</li>
</ul>
<p>(7) 为什么要用 Spring Boot？</p>
<ul>
<li>独立运行</li>
<li>简化配置</li>
<li>自动配置</li>
<li>无代码生成和XML配置</li>
<li>应用监控</li>
<li>上手容易</li>
</ul>
<p>(8) Spring Boot 的核心配置文件有哪几个？它们的区别是什么？  </p>
<ul>
<li>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。bootstrap 配置文件有以下几个应用场景。</li>
<li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；一些固定的不能被覆盖的属性；一些加密/解密的场景；</li>
</ul>
<p>(9) Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？  </p>
<p> 启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：  </p>
<ul>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan：Spring组件扫描。</li>
</ul>
<p>(10) 运行 Spring Boot 有哪几种方式？</p>
<ul>
<li>打包用命令或者放到容器中运行</li>
<li>用 Maven/ Gradle 插件运行</li>
<li>直接执行 main 方法运行</li>
</ul>
<p>(11) Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</p>
<ul>
<li>配置变更</li>
<li>JDK 版本升级</li>
<li>第三方类库升级</li>
<li>响应式 Spring 编程支持</li>
<li>HTTP/2 支持</li>
<li>配置属性绑定</li>
<li>更多改进与加强</li>
</ul>
<p>(12) Spring Boot 有哪几种读取配置的方式？</p>
<p>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量</p>
<p>(13) SpringBoot 实现热部署有哪几种方式？</p>
<ul>
<li>Spring Loaded</li>
<li>Spring-boot-devtools  </li>
</ul>
<p>(14) Spring Cloud 微服务的那点事</p>
<p><a href="https://www.toutiao.com/a6604246003090457096/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1543670961&amp;app=news_article&amp;utm_source=weixin&amp;iid=34453696208&amp;utm_medium=toutiao_android&amp;group_id=6604246003090457096" title="Spring Cloud 微服务的那点事" target="_blank" rel="external">https://www.toutiao.com/a6604246003090457096/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1543670961&amp;app=news_article&amp;utm_source=weixin&amp;iid=34453696208&amp;utm_medium=toutiao_android&amp;group_id=6604246003090457096</a>  </p>
<p>(15) Spring Cloud 你们在项目中如何使用？</p>
<p>项目中基础的Spring Cloud架构是有架构师搭建好的，我们主要安装代码规范开发微服务，并且把微服务注册到Eurake 注册中心，然后在需要调用微服务的客户端使用Feign的注解@FeignClient绑定接口来调用，同时<br>在网关项目中配置自己编写的服务地址</p>
<p>(16)  Spring Cloud 有哪些组件？</p>
<ul>
<li><p>Eurake: SpringCloud的服务发现和注册的组件</p>
<ul>
<li>注册中心 ： Eureka server<ul>
<li>1) 引入SpringBoot依赖，Eureka server依赖</li>
<li>2）编写启动类，添加注解@EnableEurekaServer</li>
<li>3）在application.yml中配置注册中心相关信息和指定注册中心的地址</li>
</ul>
</li>
<li>生产者：  Eureka Client<ul>
<li>1） 引入SpringBoot依赖，Eureka client依赖</li>
<li>2) 编写启动类，添加注解@EnableEurekaClient</li>
<li>3）在application.yml中配置相关信息同时指定服务注册中心的地址</li>
<li>4） 编写微服务（controller+service+dao）</li>
</ul>
</li>
<li>消费者：  Eureka Client<ul>
<li>1） 引入SpringBoot依赖，Eureka client依赖<ul>
<li>ribbon依赖 </li>
<li>feign依赖</li>
</ul>
</li>
<li>2) 编写启动类，添加注解@EnableEurekaClient<ul>
<li>@EnableDiscoveryClient ： 服务发现的注解</li>
<li>@EnableFeignClients  ： 开启feign的注解</li>
</ul>
</li>
<li>3）在application.yml中配置相关信息同时指定服务注册中心的地址</li>
<li>4) 编写微服务访问接口同时使用@FeignClient 指定该接口访问哪一个微服务，然后指定方法访问的url地址</li>
</ul>
</li>
</ul>
</li>
<li><p>Ribbon:负载均衡客户端，需要结合RestTemplate进行服务的调用</p>
<ul>
<li>默认的负载均衡：轮询    </li>
<li>服务器启动时，先从Eureka server获取服务列表，然后<br>在请求微服务时，通过RestTemplate进行http调用</li>
</ul>
</li>
<li><p>Feign：Feign默认集成了Ribbon</p>
<ul>
<li>Feign可以通过@FeignClient 注解标识一个接口，通过该接口生成一个代理类来进行远程的微服务调用</li>
</ul>
</li>
<li><p>Hystrix ： 熔断限流的组件</p>
<ul>
<li>为了防止微服务直接调用时，由于某一个微服务宕机导致整个无法雪崩，这里采用Hystrix来阻断对存在宕机，异常情况的请求，直接本地返回</li>
<li><p>1）Ribbon集成，首先引入相关的依赖，接着开启@EnableHystrix<br>接着在调用微服务方法上添加 @HystrixCommand(fallbackMethod = “hiError”)指定服务异常的之后本地执行的方法</p>
</li>
<li><p>2）Feign集成，在微服务绑定的接口@FeignClient(value = “service-hi”,fallback = SchedualServiceHiHystric.class)中指定异常时调用本地接口实现</p>
</li>
<li><p>判定失败：Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务，执行本地业务。</p>
</li>
<li><p>恢复服务：Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。Hystrix间隔几秒会让其中一个请求去调用远程微服务，如果调用成功，就表示服务正常，后面就重新链接</p>
</li>
<li><p>开路 断路</p>
</li>
</ul>
</li>
<li><p>Spring Cloud Config ： 集中管理中心- 特点：(1)集中管理配置文件，可以将配置文件存在本地或者用git仓库存储 （2）配置文件自动刷新，不用重启client</p>
<ul>
<li>在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client</li>
<li>Server提供配置文件的存储、以接口的形式将配置文件的内容提供出去</li>
<li>Client通过接口获取数据、并依据此数据初始化自己的应用。</li>
</ul>
</li>
<li><p>Zull (网关)：Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。</p>
<ul>
<li>1） 引入相关的依赖， Eureka client和zuul的依赖</li>
<li><p>2) 启动类添加<br>  @EnableZuulProxy  – 开启网关<br>  @EnableEurekaClient – 表示时一个eurake客户端<br>  @EnableDiscoveryClient – 开启服务发现</p>
<ul>
<li>3） 编写application.yml配置注册中心地址，<ul>
<li>配置zuul转发路径和微服务的对应关系</li>
</ul>
</li>
</ul>
</li>
<li><p>4）编写过滤器拦截请求，完成相关权限的校验</p>
</li>
</ul>
</li>
</ul>
<p>(17) springcloud如何实现服务的注册和发现</p>
<ul>
<li>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）</li>
<li>这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient  同一个服务修改端口就可以启动多个实例</li>
<li>调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务</li>
</ul>
<p>(18) ribbon和feign区别  </p>
<ul>
<li>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value=”服务名称”) 使用RestTemplate调用远程服务对应的方法</li>
<li><p>feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(“指定服务名”)</p>
</li>
<li><p>Ribbon和Feign的区别： Ribbon和Feign都是用于调用其他服务的，不过方式不同。</p>
<ul>
<li>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</li>
<li>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li>
<li>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。  </li>
</ul>
</li>
</ul>
<p>(19) springcloud和dubbo的区别</p>
<ul>
<li>最大的区别:Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式。Dubbo目前也已经支持REST风格的服务，但是在项目中使用dubbo还有很多问题需要解决，比如熔断机制，集中配置等需要自行使用其他技术，但是Spring Cloud提供一套微服务架构比较完善的解决方案。所以目前更多的企业使用Spring Cloud</li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/7. 高频面试题-框架/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/7. 高频面试题-框架/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 08:58:05" itemprop="dateModified" datetime="2018-12-12T08:58:05+08:00">2018-12-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高频面试题-框架"><a href="#高频面试题-框架" class="headerlink" title="高频面试题-框架"></a>高频面试题-框架</h2><p>(1) BeanFactory 和 ApplicationContext 有什么区别  </p>
<ul>
<li><p>BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。</p>
</li>
<li><p>BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。</p>
</li>
<li><p>ApplicationContext提供的额外的功能：国际化的功能、消息发送、响应机制、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。</p>
</li>
<li><p>加载方式的区别：BeanFactory采用的是延迟加载的形式来注入Bean；ApplicationContext则相反的，它是在Ioc启动时就一次性创建所有的Bean,好处是可以马上发现Spring配置文件中的错误，坏处是造成浪费。</p>
</li>
</ul>
<p>(2) Spring Bean 的生命周期  </p>
<ul>
<li>spring对bean进行实例化,默认bean是单例  </li>
<li>spring对bean进行依赖注入  </li>
<li>如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法  </li>
<li>如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来  </li>
<li>如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入  </li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的  postProcessBeforeInitialization接口方法  </li>
<li>如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用  </li>
<li>如果bean实现了BeanPostProcessor接口,spring将调用它们的  postProcessAfterInitialization接口方法  </li>
<li>此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁  </li>
<li>若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用<br><img src="https://images2018.cnblogs.com/blog/1368782/201804/1368782-20180409204927593-1218853531.png" alt=""></li>
</ul>
<p>(5) 说说 Spring AOP、Spring AOP 实现原理  </p>
<ul>
<li>概念:<ul>
<li>切面（Aspect） ：官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”。</li>
<li>连接点（Joinpoint） ：程序执行过程中的某一行为。</li>
<li>通知（Advice） ：“切面”对于某个“连接点”所产生的动作。</li>
<li>切入点（Pointcut） ：匹配连接点的断言，在AOP中通知和一个切入点表达式关联。</li>
<li>目标对象（Target Object） ：被一个或者多个切面所通知的对象。</li>
<li>AOP代理（AOP Proxy） 在Spring AOP中有两种代理方式，JDK动态代理和CGLIB代理。</li>
</ul>
</li>
<li><p>通知（Advice）类型:</p>
<ul>
<li>前置通知（Before advice） ：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext中在<aop:aspect>里面使用<aop:before>元素进行声明。</aop:before></aop:aspect></li>
<li>后通知（After advice） ：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext中在<aop:aspect>里面使用<aop:after>元素进行声明。</aop:after></aop:aspect></li>
<li>返回后通知（After return advice） ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext中在<aop:aspect>里面使用<after-returning>元素进行声明。</after-returning></aop:aspect></li>
<li>环绕通知（Around advice） ：包围一个连接点的通知，类似Web中Servlet规范中的Filter的doFilter方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。ApplicationContext中在<aop:aspect>里面使用<aop:around>元素进行声明。</aop:around></aop:aspect></li>
<li><p>抛出异常后通知（After throwing advice） ： 在方法抛出异常退出时执行的通知。 ApplicationContext中在<aop:aspect>里面使用<aop:after-throwing>元素进行声明。</aop:after-throwing></aop:aspect></p>
</li>
<li><p>切入点表达式 ：如execution(<em> com.spring.service.</em>.*(..))</p>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>降低模块之间的耦合度</li>
<li>使系统容易扩展</li>
<li>更好的代码复用。<br>(6) Spring 事务实现方式、事务的传播机制、默认的事务类别  </li>
</ul>
</li>
<li><p>spring事物配置的五种方式:</p>
<ul>
<li>每个Bean都有一个代理</li>
<li>所有Bean共享一个代理基类</li>
<li>使用拦截器</li>
<li>使用tx标签配置的拦截器</li>
<li>全注解</li>
</ul>
</li>
<li><p>spring里面事务的传播属性和事务隔离级别  </p>
<ul>
<li>Propagation ：key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：  </li>
<li>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。  </li>
<li>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。  </li>
<li>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。  </li>
<li>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。  </li>
<li>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。  </li>
<li>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。<br>(15) Spring注入有那些方式？  </li>
</ul>
</li>
<li><p>Set注入</p>
</li>
<li>构造器注入</li>
<li>静态工厂的方法注入</li>
<li>实例工厂的方法注入</li>
</ul>
<p>(16) 简述Spring的优缺点？  </p>
<ul>
<li>Spring 的优点？?<ul>
<li>降低了组件之间的耦合性 ，实现了软件各层之间的解耦</li>
<li>可以使用容易提供的众多服务，如事务管理，消息服务等</li>
<li>容器提供单例模式支持</li>
<li>容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能</li>
<li>容器提供了众多的辅助类，能加快应用的开发</li>
<li>spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts等</li>
<li>spring属于低侵入式设计，代码的污染极低</li>
<li>独立于各种应用服务器</li>
<li>spring的DI机制降低了业务对象替换的复杂性</li>
<li>Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部</li>
</ul>
</li>
<li>缺点:<ul>
<li>使用到了大量反射机制。反射机制非常占内存，</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/6. 高频面试题 - JAVA WEB/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/6. 高频面试题 - JAVA WEB/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 08:58:05" itemprop="dateModified" datetime="2018-12-12T08:58:05+08:00">2018-12-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高频面试题-JAVA-WEB"><a href="#高频面试题-JAVA-WEB" class="headerlink" title="高频面试题 - JAVA WEB"></a>高频面试题 - JAVA WEB</h2><p>1) cookie和session的区别  </p>
<ul>
<li>cookie数据保存在客户端，session数据保存在服务端。</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，相当重要的数据，应该使用session保存到服务端。</li>
<li>session会在一定时间内保持在服务器上，但是会占用内存资源，当访问的用户过多，会加重服务器的负载，考虑到减轻服务器的压力，可以将不重要的数据放在cookie中持久的保存。</li>
<li>单个cookie保存的数据不能超过4k，很多浏览器都限制站点最多保存20个cookie。</li>
<li>session与浏览器得会话默认会以cookie实现</li>
</ul>
<p>2) http协议简单协议   </p>
<ul>
<li>HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式。http请求由三部分组成，分别是：请求行、消息报头、请求正文，响应也包含三部分：状态行（包含HTTP版本、状态码、状态码的原因短语）、响应首部字段、响应内容实体</li>
</ul>
<p>3) Get和Post请求方式的区别？  </p>
<ul>
<li>get地址栏有参数显示  post不会再地址栏显示参数(参数是放在了请求体）</li>
<li>get不安全  post相对安全</li>
<li>get限制大小  post理论上不限制</li>
</ul>
<p>4) JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？  </p>
<p>-JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑</p>
<p>5) jsp九大内置对象  </p>
<ul>
<li>request：负责得到客户端请求的信息，对应类型：javax.servlet.http.HttpServletRequest</li>
<li>response:负责向客户端发出响应，对应类型：javax.servlet.http.HttpServletResponse</li>
<li>session:负责保存同一客户端一次会话过程中的一些信息，对应类型：javax.servlet.http.httpsession</li>
<li>out：负责管理对客户端的输出，对应类型：javax.serlvet.jsp.jspwriter</li>
<li>application:表示整个应用环境的信息，对应类型：javax.servlet.servletcontext</li>
<li>config:表示ServletConfig，对应类型：javax.servlet.servletconfig</li>
<li>exception:表示页面中发生的异常，可以通过它获得页面异常信息，对应类型：java.lang.exception</li>
<li>pagecontext:表示这个JSP页面上下文，对应类型：javax.servlet.jsp.pagecontext</li>
<li>page:表示当前JSP页面本身</li>
</ul>
<p>6) jsp四大作用域  </p>
<ul>
<li>page是代表一个页面相关的对象和属性。</li>
<li>request一个请求可能跨越多个页面。</li>
<li>session一个web回话也可以经常跨域多个请求。</li>
<li>application是代表与整个web应用程序相关的对象和属性。</li>
</ul>
<p>7) servlet的生命周期  </p>
<ul>
<li>第一次请求的时候servlet被初始化，而且只初始化一次，所以tomcat容器中每一个servlet只有一个对象存在</li>
<li>初始化后先调用init方法，只执行一遍</li>
<li>每个请求，调用一遍service -&gt; service -&gt; doGet/doPost。以多线程的方式运行</li>
<li>卸载前调用destroy方法</li>
</ul>
<p>9) 重定向和转发的区别？  </p>
<ul>
<li>重定向是客户端行为，转发是服务器端行为</li>
<li>重定向两次请求两次响应,转发一次请求一次响应</li>
<li>重定向路径需要加工程名,转发的路径不需要加工程名.</li>
<li>重定向可以跳转到任意网站,转发只能在服务器内部进行转发.</li>
<li>重定向会导致request对象信息丢失。转发则不会</li>
</ul>
<p>12) 如何防止表单重复提交？  </p>
<ul>
<li>JavaScript控制 </li>
<li>使用session实现令牌机制</li>
</ul>
<p>15）    过滤器有哪些作用，以及过滤器的生命周期  </p>
<ul>
<li>生命周期：每个Filter在tomcat启动时进行初始化，每个Filter只有一个实例对象<br>(1). Init:在服务器启动时会创建Filter实例<br>(2). doFilto:这个方法会在用户每次访问“目标资源”时执行<br>(3). destroy():服务器关闭时销毁Filter对象  </li>
<li>作用：<br>(1). 验证客户是否来自可信网络<br>(2). 对客户提交的数据进行重新编码<br>(3). 过滤掉客户的某些不应该出现的词汇<br>(4). 验证用户是否可以登录<br>(5). 验证客户的浏览器是否支持当前的应用<br>(6). 记录系统日志 </li>
</ul>
<p>16） session 共享怎么做的（分布式如何实现 session 共享）<br>  (1) 可以使用tomcat广播机制实现session共享<br>  (2) 可以使用redis+tomcat实现session共享<br> （3） 可以使用Spring Session完成session共享</p>
<p>17) Servlet是安全的吗?</p>
<ul>
<li>是线程不安全的，因为servlet是单例模式，当多个客户端共同访问的时候线程不安全。<br>尽量用局部变量，同步块，如果当前字段是不会改变的，用final修饰</li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/5. 高频面试题 - 数据库/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/5. 高频面试题 - 数据库/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 08:58:05" itemprop="dateModified" datetime="2018-12-12T08:58:05+08:00">2018-12-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高频面试题-数据库"><a href="#高频面试题-数据库" class="headerlink" title="高频面试题 - 数据库"></a>高频面试题 - 数据库</h2><p>(3) 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景  </p>
<ul>
<li><p>主要区别：</p>
<p>  1).MyISAM是非事务安全型的，而InnoDB是事务安全型的。<br>  2).MyISAM锁的粒度是表级，而InnoDB支持行级锁定。<br>  3).MyISAM支持全文类型索引，而InnoDB不支持全文索引。<br>  4).MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。<br>  5).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。<br>  6).InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</p>
</li>
<li><p>应用场景：<br>  1).MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。<br>  2).InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能</p>
</li>
</ul>
<p>(5) 索引类别（B+树索引、全文索引、哈希索引）、索引的原理  </p>
<p><a href="https://blog.csdn.net/v_victor/article/details/52232685" target="_blank" rel="external">https://blog.csdn.net/v_victor/article/details/52232685</a></p>
<p>(7) 为什么要用 B+tree作为MySQL索引的数据结构  </p>
<ul>
<li>文件很大，不可能全部存储在内存中，故要存储到磁盘上</li>
<li>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数（为什么使用B-/+Tree，还跟磁盘存取原理有关。）</li>
<li>局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数，（在许多操作系统中，页得大小通常为4k）</li>
<li>数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，(由于节点中有两个数组，所以地址连续)。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性<br><a href="http://www.cnblogs.com/tiancai/p/9024351.html" target="_blank" rel="external">http://www.cnblogs.com/tiancai/p/9024351.html</a></li>
</ul>
<p>(9) 遇到过索引失效的情况没，什么时候可能会出现，如何解决<br><a href="https://blog.csdn.net/colin_liu2009/article/details/7301089" target="_blank" rel="external">https://blog.csdn.net/colin_liu2009/article/details/7301089</a></p>
<ul>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)<ul>
<li>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
</ul>
</li>
<li>对于多列索引，不是使用的第一部分，则不会使用索引 </li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li>
</ul>
<p>(10) 如果建了1个单列索引，查询的时候查出2列，会用到这个单列索引吗？（会用到）  </p>
<ul>
<li>会用到</li>
</ul>
<p>(11) 如果建了1个包含多个列的索引，查询的时候只用了第1列，能不能用上这个索引？查三列呢？  </p>
<p>可以，查询第三列不可以必须按照顺序进行条件</p>
<p>(12) 接上题，如果where条件后面带有1个 i + 5 &lt; 100 会使用到这个索引吗？  </p>
<p>不会</p>
<p>(13) like %aaa%会使⽤索引吗? like aaa%呢?  </p>
<ul>
<li>不会  会</li>
</ul>
<p>(15) 聊下优化过的索引，怎么优化;  </p>
<p><a href="https://www.cnblogs.com/yyjie/p/7486975.html" target="_blank" rel="external">https://www.cnblogs.com/yyjie/p/7486975.html</a></p>
<p>(24) 数据库事物ACID（原子性、一致性、隔离性、持久性）  </p>
<ul>
<li>原子性：原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生</li>
<li>一致性：一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</li>
<li>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果</li>
<li>持久性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li>
</ul>
<p>(26) 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）  </p>
<p><a href="https://my.oschina.net/bigdataer/blog/1976010" target="_blank" rel="external">https://my.oschina.net/bigdataer/blog/1976010</a></p>
<ul>
<li>Read uncommitted 读未提交：事务B读取了事务A尚未提交的数据，可能出现脏读</li>
<li>Read committed 读提交：事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变，避免了脏读，但是可能会造成不可重复读</li>
<li>Repeatable read 重复读： ，避免了不可重复读，但还有可能出现幻读。注：MySQL的默认隔离级别就是Repeatable read。</li>
<li>Serializable 序列化：Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</li>
</ul>
<p>(35) limit 20000 加载很慢怎么解决<br><a href="http://uule.iteye.com/blog/2422189" target="_blank" rel="external">http://uule.iteye.com/blog/2422189</a></p>
<p>(36) 如何选择合适的分布式主键方案 </p>
<ul>
<li>redis的自增</li>
<li>oracle数据库的序列</li>
<li>手动UUID</li>
<li>推特雪花算法 </li>
</ul>
<p>(38) 说说 SQL 优化之道 </p>
<p><a href="https://blog.csdn.net/zly9923218/article/details/51007554" target="_blank" rel="external">https://blog.csdn.net/zly9923218/article/details/51007554</a></p>
<p>(40) 数据库高并发下的优化思路;  </p>
<ul>
<li>代码中sql语句优化</li>
<li>数据库字段优化，索引优化</li>
<li>加缓存，redis/memcache等</li>
<li>主从，读写分离</li>
<li>分区表</li>
<li>垂直拆分，解耦模块</li>
<li>水平切分</li>
</ul>
<p>(54) mysql优化课程：[<a href="http://www.imooc.com/learn/194" target="_blank" rel="external">http://www.imooc.com/learn/194</a>]</p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/4. 高频面试题-设计模式/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/4. 高频面试题-设计模式/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 08:58:04" itemprop="dateModified" datetime="2018-12-12T08:58:04+08:00">2018-12-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高频面试题-设计模式"><a href="#高频面试题-设计模式" class="headerlink" title="高频面试题-设计模式"></a>高频面试题-设计模式</h2><p>(1) 常见的设计模式  </p>
<ul>
<li>软件设计模式的分类<ul>
<li>创建型:创建对象时，不再由我们直接实例化对象,工厂方法、抽象工厂模式、单例模式</li>
<li>结构型:用于帮助将多个对象组织成更大的结构,适配器模式,装饰器模式、门面模式、亨元模式和代理模式</li>
<li>行为型:用于帮助系统间各对象的通信，以及如何控制复杂系统中流程,命令模式、观察者模式、策略模式</li>
</ul>
</li>
</ul>
<p>(2) 设计模式的的六大原则及其含义  </p>
<ul>
<li>开闭原则（Open Close Principle）<ul>
<li>开闭原则的意思是：对扩展开放，对修改关闭。</li>
<li>对原有代码不修改，可以进行拓展，实现热插拔。</li>
</ul>
</li>
<li>里氏代换原则（Liskov Substitution Principle）<ul>
<li>里氏代还原则是面向对象设计的基本原则之一。原则：基类存在的的地方，子类一定存在。</li>
</ul>
</li>
<li>依赖倒转原则（Dependence Inversion Principle）<ul>
<li>这个原则是开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体。</li>
</ul>
</li>
<li>接口隔离原则（Interface Segregation Principle）<ul>
<li>使用多个隔离的接口，降低类之间的耦合度。便于升级和维护，降低依赖，降低耦合。</li>
</ul>
</li>
<li>迪米特法则，又称最少知道原则（Demeter Principle）<ul>
<li>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
</ul>
</li>
<li>合成复用原则（Composite Reuse Principle）<ul>
<li>尽量使用合成、聚合的方式，而不是用继承。</li>
</ul>
</li>
</ul>
<p>(3) 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式  </p>
<ul>
<li>懒汉式单例<ul>
<li>优点：第一次调用才初始化，避免内存浪费。</li>
<li>缺点：必须加锁synchronized 才能保证单例，（如果两个线程同时调用getInstance方法，会chuxia）但加锁会影响效率。 </li>
</ul>
</li>
<li>饿汉式单例<ul>
<li>优点：没有加锁，执行效率会提高。</li>
<li>缺点：类加载时就初始化，浪费内存。</li>
</ul>
</li>
<li>登记式模式（holder）<br>  <img src="https://img-blog.csdn.net/2018030811254564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWUVDcmF6eQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><ul>
<li>内部类只有在外部类被调用才加载，产生SINGLETON实例；又不用加锁。此模式有上述两个模式的优点，屏蔽了它们的缺点，是最好的单例模式。</li>
</ul>
</li>
</ul>
<p>(4) JDK中哪些实现了单例模式？  </p>
<pre><code>java.lang.Runtime  java.awt.Desktop#getDesktop()
</code></pre><p>(5) 设计模式在实际场景中的应用  </p>
<ul>
<li>装饰者模式+增强HttpServletRequest对象</li>
<li>IO编程中使用大量装饰者模式</li>
<li>集合中使用了大量组合模式</li>
<li>JDBC编程使用桥接模式</li>
</ul>
<p>(6) Spring中用到了哪些设计模式  </p>
<ul>
<li>代理模式：在AOP和remoting中被用的比较多。</li>
<li>单例模式：在spring配置文件中定义的bean默认为单例模式。</li>
<li>模板方法模式：用来解决代码重复的问题。</li>
<li>前端控制器模式：Spring提供了DispatcherServlet来对请求进行分发。</li>
<li>依赖注入模式：贯穿于BeanFactory / ApplicationContext接口的核心理念。</li>
<li>工厂模式：BeanFactory用来创建对象的实例。</li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/3. 高频面试题-多线程/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/3. 高频面试题-多线程/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 08:58:03" itemprop="dateModified" datetime="2018-12-12T08:58:03+08:00">2018-12-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##高频面试题-多线程</p>
<p>(3) 创建线程的方式</p>
<ul>
<li>继承Thread</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li><p>区别：</p>
<ul>
<li><ol>
<li>实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；</li>
</ol>
</li>
<li><ol>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</li>
</ol>
</li>
<li><ol>
<li>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>(4) 线程的生命周期，线程状态以及API怎么操作会发生这种转换；<br><img src="https://img-blog.csdn.net/20171108141306521?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3MzQyMTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>(5) 一个线程连着调用start两次会出现什么情况？  </p>
<ul>
<li>线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</li>
</ul>
<p>(6) wait方法能不能被重写，wait能不能被中断；  </p>
<ul>
<li><p>wait时间到或被中断唤醒，不一定会继续执行或者跳到catch里，而是还需要等待获得锁。<br>如果wait时间到或被中断唤醒，而T2还在syn里，那么T1还是会等待。</p>
</li>
<li><p>wait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，这些方法都只能在同步方法或同步块中调用</p>
</li>
<li>sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁。</li>
</ul>
<p>(7) 线程池的实现原理？四种线程池？重要参数及原理？任务拒接策略有哪几种？  </p>
<ul>
<li>线程池内部维护了一个线程列表，我们使用线程池只需要定义好任务，然后提交给线程池，而不用关心该任务是如何执行、被哪个线程执行，以及什么时候执行.jdk1.5引入Executor线程池框架Executor线程池框架,有以下四种实现</li>
<li>newFixedThreadPool()：初始化一个指定线程数的线程池，其中corePoolSize == maxiPoolSize，使用LinkedBlockingQuene作为阻塞队列。<blockquote>
<p>特点：即使当线程池没有可执行任务时，也不会释放线程。</p>
</blockquote>
</li>
<li>newCachedThreadPool()：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；<blockquote>
<p>特点：在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；</p>
</blockquote>
</li>
<li>newSingleThreadExecutor():初始化只有一个线程的线程池，内部使用LinkedBlockingQueue作为阻塞队列。<blockquote>
<p>如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</p>
</blockquote>
</li>
<li>newScheduledThreadPool():初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</li>
<li>提交任务给线程池<ul>
<li>Executor.execute(Runnable command);<ul>
<li>ExecutorService.submit(Callable<t> task);</t></li>
</ul>
</li>
</ul>
</li>
<li>线程池的关闭<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务；</p>
</blockquote>
<p>(10) 说说 CountDownLatch、CyclicBarrier 原理和区别</p>
<ul>
<li>CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行， await()可以让线程等待，countDown() 每调用一次就减1.指定减到0所有等待的线程就开始执行。</li>
<li>CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。<br>当所有线程都准备好再一起执行。</li>
</ul>
<p>(13) 多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？  </p>
<p>采用Read-Write Lock Pattern是一种将对于共享资源的访问与修改操作分离，称为读写分离。用单独的线程来处理读写，允许多个读线程同时读，但是不能多个写线程同时写。ReadWriteLock锁</p>
<p>  前置处理(获取锁定)</p>
<pre><code>try{

     实际操作
}finally{
    后续处理(释放锁)
}
</code></pre><p>(16) wait/notify/notifyAll⽅法需不需要被包含在synchronized块中？这是为什么？  </p>
<ul>
<li>需要</li>
<li>因为wait/notify/notifyAll需要通过监视器操作对象锁。达到对对象锁得释放和获取</li>
</ul>
<p>(17) ExecutorService你一般是怎么⽤的？是每个Service放一个还是个项目放一个？有什么好处？</p>
<ul>
<li>Java线程池ExecutorService<br>　　如果有一套相同逻辑的多个任务的情况下,应用一个线程池是个好选择。<br>　　如果项目中有多套不同的这种任务,那每套任务应该一个线程池不是很正常的吗</li>
</ul>
<p>(18) 两个线程设计题。记得一个是：t1,t2,t3，让t1，t2执行完才执行t3，原生实现。 </p>
<p>– 使用线程的join() 方法控制</p>
<p>(8) synchronized 与 lock 的区别  </p>
<ul>
<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li>
</ul>
<p>(3) 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待） </p>
<p>(10) CAS无锁的概念、乐观锁和悲观锁  </p>
<ul>
<li>CAS（比较与交换，Compare and swap） 是一种有名的无锁算法，无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）</li>
<li>当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 </li>
</ul>
<p>(11) Java中有哪些同步方案（重量级锁、显式锁、并发容器、并发同步器、CAS、volatile、AQS等） </p>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/2. 高频面试题-JVM/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/2. 高频面试题-JVM/" class="post-title-link" itemprop="url">高频面试题-JVM</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:57:13 / 修改时间：20:57:52" itemprop="dateCreated datePublished" datetime="2019-01-10T20:57:13+08:00">2019-01-10</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="高频面试题-JVM"><a href="#高频面试题-JVM" class="headerlink" title="高频面试题-JVM"></a>高频面试题-JVM</h2><p>(1) JVM运行时内存区域划分  </p>
<ul>
<li>Java程序具体执行的过程：<br><img src="https://images0.cnblogs.com/i/288799/201405/281630330728961.jpg" alt=""></li>
<li>运行时数据区包括哪几部分：<br><img src="https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg" alt=""><br>JDK8： 取消了整个永久代区域，取而代之的是元空间。常量池就不存放在堆中了，而是存放在方法区里面，与堆栈是并列关系<br><img src="https://img-blog.csdn.net/20180621164446655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmRlcmx1c3RMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">  </li>
<li>程序计数器：程序计数器（Program Counter Register），也有称作为PC寄存器。它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</li>
<li>Java栈也称作虚拟机栈（Java Vitual Machine Stack），也就是我们常常所说的栈.Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息.当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。<ul>
<li>局部变量表:局部变量（包括在方法中声明的非静态变量以及函数形参）</li>
<li>操作数栈:不断执行语句的过程</li>
<li>指向运行时常量池的引用:因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。  </li>
<li>方法返回地址:当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。<br><img src="https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg" alt=""></li>
</ul>
</li>
<li>本地方法栈:本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。</li>
<li>堆：Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。另外，堆是被所有线程共享的，在JVM中只有一个堆。</li>
<li>方法区：方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。<br>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法</li>
</ul>
<p>(4) 堆分为哪几块，比如说新生代老生代，那么新生代又分为什么两个Survivor？  </p>
<ul>
<li>整个堆区划分为新生代和老年代；新生代又被划分成 Eden 空间、 From Survivor 和 To Survivor 三块区域。 </li>
<li>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li>
<li>首先说如果没有Survivor区会出现什么情况：此时每触发一次Minor GC，就会把Eden区的对象复制到老年代，这样当老年代满了之后会触发Major Gc(通常伴随着MinorGC，可以看做Full GC)，比较耗时。</li>
<li>如果只有1个Survivor区，那当Eden区满了之后，就会复制对象到Survivor区，容易产生内存碎片化。严重影响性能。所以使用2个Survivor区，始终保持有一个空的Survivor区，可以避免内存碎片化。</li>
</ul>
<p>(7) 如何判断对象是否可以回收或存活（引用计数法与GC Root可达性分析法区别；  ）</p>
<ul>
<li>引用数法：引用计数法师垃圾收集的早期策略，在这中方法中，堆中每个对象都有一个引用计数，每当有一个地方引用他时，引用计数值就+1,当引用失效时，引用计数值就-1，任何时刻引用计数值为0的对象就是可以被回收，当一个对象被垃圾收集时，被它引用 的对象引用计数值就-1，所以在这种方法中一个对象被垃圾收集会导致后续其他对象的垃圾收集行动。<ul>
<li>缺点：不完全准确，当两个对象相互引用的时候就无法回收，导致内存泄漏。</li>
</ul>
</li>
<li>可达性分析算法：基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br>可作为GC Roots对象的包括如下几种：<blockquote>
<p>a.虚拟机栈(栈桢中的本地变量表)中的引用的对象<br> b.方法区中的类静态属性引用的对象<br> c.方法区中的常量引用的对象<br> d.本地方法栈中JNI的引用的对象   </p>
</blockquote>
</li>
</ul>
<p>(8) 常见的GC回收算法及其含义  </p>
<ul>
<li>标记-清除算法：<ul>
<li>标记阶段：先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象；</li>
<li>清除阶段：清除所有未被标记的对象。</li>
<li>缺点：标记和清除过程效率不高，标记清除之后会产生大量不连续的内存碎片。</li>
</ul>
</li>
<li>复制算法：（新生代的GC）<ul>
<li>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</li>
<li>缺点：内存缩小为原来的一半。</li>
</ul>
</li>
<li>标记-整理算法：（老年代的GC）<ul>
<li>标记阶段：先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象</li>
<li>整理阶段：将将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间  </li>
<li>缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。</li>
</ul>
</li>
<li>分代收集算法：<ul>
<li>存活率低：少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。</li>
<li>存活率高：大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。</li>
</ul>
</li>
</ul>
<p>(28) 类加载的过程：加载、验证、准备、解析、初始化<br><img src="http://static.zybuluo.com/Rico123/ojhhtids41ivtuowfj74mkb2/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" alt=""></p>
<p>(29) 什么情况下会触发类加载；   </p>
<pre><code>&gt; 创建类的实例  
&gt; 访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。  
&gt; 访问类的静态方法  
&gt; 反射如(Class.forName(&quot;my.xyz.Test&quot;))  
&gt; 当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化  
&gt; 虚拟机启动时，定义了main()方法的那个类先初始化 
</code></pre>
          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/JAVA集合/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YC"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驰哥哥教你学Java"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/JAVA集合/" class="post-title-link" itemprop="url">高频面试题-集合</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 16:47:24 / 修改时间：20:57:58" itemprop="dateCreated datePublished" datetime="2019-01-10T16:47:24+08:00">2019-01-10</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##高频面试题-集合</p>
<p>(1) Collection和Collections的区别  </p>
<ul>
<li>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<ul>
<li>Collections.sort     对集合排序（需要实现int compareTo） </li>
<li>Collections.synchronizedMap      返回一个线程安全的map </li>
<li>Collections.binarySearch     二分查找一个元素 </li>
<li>Collections.shuffle      对集合进行随机排序（就是指每次排序后都不同） </li>
</ul>
</li>
<li>Collection是个java.util下的接口，它是各种集合结构的父接口。 <ul>
<li>List,Set的父接口</li>
<li>Collection跟Map没有联系</li>
</ul>
</li>
</ul>
<p>(2) List 和 Set 区别  </p>
<ul>
<li>list：列表，表达形式 [ ]，或者list()，有序，通过索引值进行查找</li>
<li>set：集合,表达形式set([ ])，无序自动去重。可以做集合的交集，并集，差集</li>
</ul>
<p>(3) Set内存放的元素为什么不可以重复，内部是如何保证和实现的？ </p>
<ul>
<li>HashSet类实现了Set接口， 其底层其实是包装了一个HashMap去实现的。HashSet采用HashCode算法来存取集合中的元素，因此具有比较好的读取和查找性能。首先根据key的hashCode()返回值决定该Entry的存储位置，如果两个key的hash值相同，那么它们的存储位置相同。如果这个两个key的equals比较返回true。那么新添加的Entry的value会覆盖原来的Entry的value，key不会覆盖</li>
</ul>
<p>(4) Arraylist 与 LinkedList 区别   </p>
<ul>
<li>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；</li>
<li>对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；</li>
<li>对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢<blockquote>
<p>所以当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣与ArrayList，且越靠近后面越差。所以个人觉得，一般首选用ArrayList，由于LinkedList可以实现栈、队列以及双端队列等数据结构，所以当特定需要时候，使用LinkedList，当然咯，数据量小的时候，两者差不多，视具体情况去选择使用；当数据量大的时候，如果只需要在靠前的部分插入或删除数据，那也可以选用LinkedList，反之选择ArrayList反而效率更高</p>
</blockquote>
</li>
</ul>
<p>(5) Arraylist与LinkedList,Map默认空间是多少； </p>
<ul>
<li>jdk1.6 ArrayList 初始化大小是 10,扩容大小规则是，扩容后的大小= 原始大小+原始大小/2 + 1</li>
<li>jdk1.7 ArrayList 初始化大小是 0,第一次添加元素时,会将容量设置为10,扩容大小规则是，扩容后的大小= 原始大小+原始大小/2 </li>
<li>linkedList 是一个双向链表，没有初始化大小，也没有扩容的机制</li>
<li>HashMap 初始化大小是 16 ，扩容因子默认0.75（可以指定初始化大小，和扩容因子）<br>扩容机制.(当前大小 和 当前容量 的比例超过了 扩容因子，就会扩容，扩容后大小为 一倍。例如：初始大小为 16 ，扩容因子 0.75 ，当容量为12的时候，比例已经是0.75 。触发扩容，扩容后的大小为 32.)</li>
</ul>
<p>(6) ArrayList 与 Vector 区别  </p>
<ul>
<li>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程<br>序不安全</li>
<li>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过<br>了容量，就需要增加 ArrayList 与 Vector 的存储空间。Vector 增长原来的一倍， ArrayList 增加原来的0.5倍。</li>
</ul>
<p>(7) HashSet 和 HashMap 区别  </p>
<ul>
<li>HashMap实现Map接口，存储键值对，HashMap使用键（Key）计算Hashcode</li>
<li>HashSet实现Set接口，底层采用HashMap实现，仅存储对象，HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false。</li>
</ul>
<p>(8) HashMap 和 Hashtable 的区别  </p>
<ul>
<li>HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。HashMap中，null可以作为键，这样的键只有一个；</li>
<li>Hashtable也是JDK1.0引入的类，是线程安全的，Hashtable中，key和value都不允许出现null值。</li>
<li>遍历方式： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</li>
<li>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值</li>
<li>扩容机制和初始化大小： HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 </li>
</ul>
<p>(9) 谈谈HashMap，哈希表解决hash冲突的方法； </p>
<ul>
<li>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间,提高查询速度</li>
</ul>
<p>(10) HashMap 和 ConcurrentHashMap 的区别  </p>
<ul>
<li>从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li>
</ul>
<p>(13) ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数  </p>
<ul>
<li><p>这也就是为什么sumCount()中需要遍历counterCells数组，sum累加CounterCell.value值了<br>(16) Java Collections和Arrays的sort方法默认的排序方法是什么； </p>
</li>
<li><p>java的Collections.sort算法调用的是合并排序</p>
</li>
<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序</li>
</ul>
<p>(17) ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)） </p>
<ul>
<li><p>ArrayList 是线性表（数组）</p>
<ul>
<li>get() 直接读取第几个下标，复杂度 O(1)</li>
<li>add(E) 添加元素，直接在后面添加，复杂度O（1）</li>
<li>add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）</li>
<li>remove（）删除元素，后面的元素需要逐个移动，复杂度O（n）</li>
</ul>
</li>
<li><p>LinkedList 是链表的操作</p>
<ul>
<li>get() 获取第几个元素，依次遍历，复杂度O(n)</li>
<li>add(E) 添加到末尾，复杂度O(1)</li>
<li>add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)</li>
<li>remove（）删除元素，直接指针指向操作，复杂度O(1)</li>
</ul>
</li>
</ul>
<p>(18) HashMap在什么时候时间复杂度是O（1），什么时候是O（n），什么时候又是O（logn）； </p>
<ul>
<li>链表的长度尽可能短，理想状态下链表长度都为1 </li>
<li>当 Hash 冲突严重时，如果没有红黑树，那么在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为O(N)。 </li>
<li>采用红黑树之后可以保证查询效率O(logn)</li>
</ul>

          
        
      
    </div>

    

    
    
    
	<div>

</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YC</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YC</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.2.2</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
